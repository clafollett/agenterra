//! Integration tests using mock configuration
//!
//! These tests can use either:
//! 1. A simple test configuration (always available)
//! 2. An external mock server (via MOCK_SERVER_PATH environment variable)

use {{ crate_name }}::domain::client::McpClient;
use {{ crate_name }}::application::config::ServerProfile;
use std::env;
use std::time::Duration;
use chrono::Utc;
use uuid::Uuid;

/// Get a server profile for testing
fn get_test_server_profile() -> Result<ServerProfile, String> {
    // First check if MOCK_SERVER_PATH is set (by E2E tests or user)
    if let Ok(path) = env::var("MOCK_SERVER_PATH") {
        return Ok(ServerProfile {
            id: uuid::Uuid::new_v4().to_string(),
            name: "external-mock-server".to_string(),
            description: Some("External mock server for testing".to_string()),
            command: path,
            args: vec![],
            environment: None,
            timeout: Some(30),
            is_default: false,
            transport: Some("stdio".to_string()),
            disabled: false,
            always_allowed: Some(vec!["echo".to_string(), "test_allowed".to_string()]),
            disabled_tools: Some(vec!["test_disabled".to_string()]),
            created_at: chrono::Utc::now(),
            last_used: None,
        });
    }
    
    // Use simple test configuration (no external dependencies required)
    Ok(ServerProfile {
        id: Uuid::new_v4().to_string(),
        name: "test-mock-server".to_string(),
        description: Some("Simple test configuration".to_string()),
        command: "echo".to_string(),
        args: vec!["mock".to_string()],
        environment: None,
        timeout: Some(30),
        is_default: false,
        transport: Some("stdio".to_string()),
        disabled: false,
        always_allowed: Some(vec!["echo".to_string(), "test_allowed".to_string()]),
        disabled_tools: Some(vec!["test_disabled".to_string()]),
        created_at: Utc::now(),
        last_used: None,
    })
}

#[tokio::test]
async fn test_client_with_mock_server() {
    let profile = match get_test_server_profile() {
        Ok(profile) => profile,
        Err(e) => {
            eprintln!("Skipping test: {}", e);
            return;
        }
    };

    // Create client and connect
    let mut client = McpClient::new_with_timeout(30).await.unwrap();
    
    // Set the server profile for permission tracking
    client.set_server_profile(profile.clone());
    
    // Build connection config
    let config = {{ crate_name }}::domain::connection::ConnectionConfigBuilder::new()
        .command(&profile.command)
        .args(profile.args.clone())
        .timeout(Duration::from_secs(profile.timeout.unwrap_or(30)))
        .build()
        .unwrap();
    
    match client.connect(config).await {
        Ok(_) => {
            println!("✅ Successfully connected to mock server");
            
            // Test listing tools
            match client.list_tools().await {
                Ok(tools) => {
                    assert!(!tools.is_empty(), "Should have tools available");
                    assert!(tools.iter().any(|t| t == "echo"), "Should have echo tool");
                    println!("✅ Successfully listed {} tools", tools.len());
                }
                Err(e) => {
                    eprintln!("Failed to list tools: {}", e);
                }
            }
            
            // Test calling echo tool  
            match client.call_tool("echo", serde_json::json!({
                "message": "Hello from test!"
            })).await {
                Ok(result) => {
                    println!("✅ Successfully called echo tool: {:?}", result);
                }
                Err(e) => {
                    eprintln!("Failed to call tool: {}", e);
                }
            }
            
            // Disconnect
            client.disconnect().await.ok();
        }
        Err(e) => {
            eprintln!("Failed to connect to mock server: {}", e);
            eprintln!("Mock server connection failed (this is expected if no external mock server is configured)");
        }
    }
}

#[tokio::test] 
async fn test_disabled_tools_with_mock_server() {
    let profile = match get_test_server_profile() {
        Ok(profile) => profile,
        Err(e) => {
            eprintln!("Skipping test: {}", e);
            return;
        }
    };

    let mut client = McpClient::new_with_timeout(30).await.unwrap();
    
    let config = {{ crate_name }}::domain::connection::ConnectionConfigBuilder::new()
        .command(&profile.command)
        .args(profile.args.clone())
        .timeout(Duration::from_secs(profile.timeout.unwrap_or(30)))
        .build()
        .unwrap();
    
    client.set_server_profile(profile);
    
    if client.connect(config).await.is_ok() {
        // Try to call disabled tool - should fail
        match client.call_tool("test_disabled", serde_json::json!({"input": "test"})).await {
            Err(e) => {
                assert!(e.to_string().contains("disabled"), "Error should mention tool is disabled");
                println!("✅ Correctly blocked disabled tool");
            }
            Ok(_) => {
                panic!("Should not be able to call disabled tool");
            }
        }
        
        // Echo tool should still work
        match client.call_tool("echo", serde_json::json!({"message": "test"})).await {
            Ok(_) => println!("✅ Non-disabled tool works"),
            Err(e) => panic!("Non-disabled tool should work: {}", e),
        }
        
        client.disconnect().await.ok();
    }
}

#[tokio::test]
async fn test_always_allowed_tools_with_mock_server() {
    let profile = match get_test_server_profile() {
        Ok(profile) => profile,
        Err(e) => {
            eprintln!("Skipping test: {}", e);
            return;
        }
    };

    let mut client = McpClient::new_with_timeout(30).await.unwrap();
    
    let config = {{ crate_name }}::domain::connection::ConnectionConfigBuilder::new()
        .command(&profile.command)
        .args(profile.args.clone())
        .timeout(Duration::from_secs(profile.timeout.unwrap_or(30)))
        .build()
        .unwrap();
    
    client.set_server_profile(profile);
    
    if client.connect(config).await.is_ok() {
        // Test that always_allowed tools work
        for tool_name in &["test_allowed", "echo"] {
            match client.call_tool(tool_name, serde_json::json!({"input": "test"})).await {
                Ok(_) => println!("✅ Always allowed tool '{}' works", tool_name),
                Err(e) => panic!("Always allowed tool '{}' should work: {}", tool_name, e),
            }
        }
        
        client.disconnect().await.ok();
    }
}