//! Interactive REPL interface for MCP client

use crate::infrastructure::error::Result;
use rustyline::error::ReadlineError;
use rustyline::DefaultEditor;
use serde_json::{json, Value};
use tracing::{error, info, debug};

use crate::domain::client::McpClient;

/// REPL interface for MCP client
pub struct McpRepl {
    client: McpClient,
    editor: DefaultEditor,
    session_id: Option<String>,
    server_name: String,
}

impl McpRepl {
    /// Create a new REPL instance
    pub fn new(client: McpClient, server_name: String) -> Self {
        let editor = DefaultEditor::new().expect("Failed to create readline editor");
        
        Self { 
            client, 
            editor,
            session_id: None,
            server_name,
        }
    }
    
    /// Set the session ID for tracking
    pub fn set_session_id(&mut self, session_id: String) {
        self.session_id = Some(session_id);
    }

    /// Run the interactive REPL
    pub async fn run(&mut self) -> Result<()> {
        info!("Starting MCP client REPL interface");
        println!("{{ project_name }} - Interactive REPL");
        println!("Type 'help' for available commands, 'quit' to exit");
        println!();

        self.show_capabilities().await;

        loop {
            let readline = self.editor.readline("mcp> ");
            match readline {
                Ok(line) => {
                    let line = line.trim();
                    if line.is_empty() {
                        continue;
                    }

                    self.editor.add_history_entry(line).ok();

                    match self.handle_command(line).await {
                        Ok(should_continue) => {
                            if !should_continue {
                                break;
                            }
                        }
                        Err(e) => {
                            error!("REPL command failed: {}", e);
                        }
                    }
                }
                Err(ReadlineError::Interrupted) => {
                    println!("Use 'quit' to exit");
                }
                Err(ReadlineError::Eof) => {
                    break;
                }
                Err(err) => {
                    error!("Readline error: {:?}", err);
                    break;
                }
            }
        }

        println!("Goodbye!");
        info!("Shutting down MCP client REPL");
        self.client.disconnect().await?;
        Ok(())
    }

    /// Handle a command from the REPL
    async fn handle_command(&mut self, command: &str) -> Result<bool> {
        let parts: Vec<&str> = command.split_whitespace().collect();
        if parts.is_empty() {
            return Ok(true);
        }

        debug!("Processing REPL command: {}", parts[0]);

        match parts[0] {
            "help" | "h" => {
                self.show_help();
            }
            "tools" | "t" => {
                self.show_tools().await;
            }
            "resources" | "r" => {
                self.show_resources().await;
            }
            "prompts" | "p" => {
                self.show_prompts().await;
            }
            "call" | "c" => {
                if parts.len() < 2 {
                    println!("Usage: call <tool_name> [arguments_json]");
                } else {
                    let tool_name = parts[1];
                    let args = if parts.len() > 2 {
                        let args_str = parts[2..].join(" ");
                        serde_json::from_str(&args_str).unwrap_or_else(|_| json!({}))
                    } else {
                        json!({})
                    };
                    
                    self.call_tool(tool_name, args).await?;
                }
            }
            "get" | "g" => {
                if parts.len() < 2 {
                    println!("Usage: get <resource_uri>");
                } else {
                    let uri = parts[1];
                    self.get_resource(uri).await?;
                }
            }
            "prompt" => {
                if parts.len() < 2 {
                    println!("Usage: prompt <prompt_name> [arguments_json]");
                } else {
                    let prompt_name = parts[1];
                    let args = if parts.len() > 2 {
                        let args_str = parts[2..].join(" ");
                        Some(serde_json::from_str(&args_str).unwrap_or_else(|_| json!({})))
                    } else {
                        None
                    };
                    
                    self.get_prompt(prompt_name, args).await?;
                }
            }
            "status" | "s" => {
                self.show_status().await;
            }
            "clear" => {
                print!("\x1B[2J\x1B[1;1H");
            }
            "quit" | "exit" | "q" => {
                return Ok(false);
            }
            _ => {
                println!("Unknown command: {}. Type 'help' for available commands.", parts[0]);
            }
        }

        Ok(true)
    }

    /// Show available capabilities
    async fn show_capabilities(&mut self) {
        let tools = match self.client.list_tools().await {
            Ok(tools) => tools,
            Err(e) => {
                error!("Failed to list tools: {}", e);
                vec![]
            }
        };
        let resources = match self.client.list_resources().await {
            Ok(resources) => resources,
            Err(e) => {
                error!("Failed to list resources: {}", e);
                vec![]
            }
        };
        let prompts = match self.client.list_prompts().await {
            Ok(prompts) => prompts,
            Err(e) => {
                error!("Failed to list prompts: {}", e);
                vec![]
            }
        };

        println!("Connected to: {}", self.server_name);
        if let Some(version) = self.client.server_version() {
            println!("Server version: {}", version);
        }
        println!();
        println!("Server Capabilities:");
        println!("  Tools: {}", tools.len());
        println!("  Resources: {}", resources.len());
        println!("  Prompts: {}", prompts.len());
        println!();
    }

    /// Show help message
    fn show_help(&self) {
        println!("Available commands:");
        println!("  help, h          - Show this help message");
        println!("  tools, t         - List available tools");
        println!("  resources, r     - List available resources");
        println!("  prompts, p       - List available prompts");
        println!("  call, c <tool> [args] - Call a tool with optional JSON arguments");
        println!("  get, g <uri>     - Get a resource by URI");
        println!("  prompt <name> [args] - Get a prompt with optional JSON arguments");
        println!("  status, s        - Show connection status");
        println!("  clear            - Clear screen");
        println!("  quit, exit, q    - Exit the REPL");
        println!();
    }

    /// Show available tools
    async fn show_tools(&mut self) {
        let tools = match self.client.list_tools().await {
            Ok(tools) => tools,
            Err(e) => {
                error!("Failed to list tools: {}", e);
                return;
            }
        };
        
        if tools.is_empty() {
            println!("No tools available");
            return;
        }

        println!("Available tools:");
        for tool_name in tools {
            println!("  {}", tool_name);
        }
        println!();
    }

    /// Show available resources
    async fn show_resources(&mut self) {
        let resources = match self.client.list_resources().await {
            Ok(resources) => resources,
            Err(e) => {
                error!("Failed to list resources: {}", e);
                return;
            }
        };
        
        if resources.is_empty() {
            println!("No resources available");
            return;
        }

        println!("Available resources:");
        for resource in resources {
            println!("  {}: {}", resource.uri, resource.description.as_deref().unwrap_or("No description"));
        }
        println!();
    }

    /// Show available prompts
    async fn show_prompts(&mut self) {
        let prompts = match self.client.list_prompts().await {
            Ok(prompts) => prompts,
            Err(e) => {
                error!("Failed to list prompts: {}", e);
                return;
            }
        };
        
        if prompts.is_empty() {
            println!("No prompts available");
            return;
        }

        println!("Available prompts:");
        for prompt_name in prompts {
            println!("  {}", prompt_name);
        }
        println!();
    }

    /// Call a tool
    async fn call_tool(&mut self, tool_name: &str, args: Value) -> Result<()> {
        match self.client.call_tool(tool_name, args).await {
            Ok(result) => {
                println!("Tool result:");
                println!("{}", serde_json::to_string_pretty(&result)?);
                println!();
            }
            Err(e) => {
                error!("Failed to call tool '{}': {}", tool_name, e);
            }
        }
        Ok(())
    }

    /// Get a resource
    async fn get_resource(&mut self, uri: &str) -> Result<()> {
        match self.client.get_resource(uri).await {
            Ok(content) => {
                println!("Resource content:");
                println!("{}", serde_json::to_string_pretty(&content)?);
                println!();
            }
            Err(e) => {
                error!("Failed to get resource '{}': {}", uri, e);
            }
        }
        Ok(())
    }

    /// Get a prompt
    async fn get_prompt(&mut self, name: &str, args: Option<Value>) -> Result<()> {
        match self.client.get_prompt(name, args).await {
            Ok(content) => {
                println!("Prompt content:");
                println!("{}", serde_json::to_string_pretty(&content)?);
                println!();
            }
            Err(e) => {
                error!("Failed to get prompt '{}': {}", name, e);
            }
        }
        Ok(())
    }

    /// Show connection status
    async fn show_status(&mut self) {
        println!("Connection Status:");
        println!("  Server: {}", self.server_name);
        if let Some(version) = self.client.server_version() {
            println!("  Version: {}", version);
        }
        if let Some(protocol) = self.client.protocol_version() {
            println!("  Protocol: {}", protocol);
        }
        println!("  Connected: {}", self.client.is_connected());
        
        // Get counts asynchronously
        let tools_count = match self.client.list_tools().await {
            Ok(tools) => tools.len(),
            Err(_) => 0,
        };
        let resources_count = match self.client.list_resources().await {
            Ok(resources) => resources.len(),
            Err(_) => 0,
        };
        let prompts_count = match self.client.list_prompts().await {
            Ok(prompts) => prompts.len(),
            Err(_) => 0,
        };
        
        println!("  Tools: {}", tools_count);
        println!("  Resources: {}", resources_count);
        println!("  Prompts: {}", prompts_count);
        println!();
    }
}