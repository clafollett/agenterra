//! Configuration command handlers for {{ project_name }}

use crate::application::config::{ConfigManager, ServerProfile};
use crate::application::validation::InputValidator;
use crate::infrastructure::database::manager::DatabaseManager;
use crate::infrastructure::error::{ClientError, Result};
use crate::cli::args::ServerCommands;
use std::sync::Arc;
use chrono::Utc;
use tracing::{info, warn};
use uuid::Uuid;
use serde_json;

/// Handle server management commands
pub async fn handle_server_command(action: &ServerCommands) -> Result<()> {
    // Initialize shared database
    let db = Arc::new(DatabaseManager::new().await?);
    let config_manager = ConfigManager::new(db).await?;
    
    match action {
        ServerCommands::Add { 
            name, 
            description, 
            command,
            args, 
            timeout,
            transport,
            env,
            disabled_tools,
            set_default 
        } => {
            // Validate inputs
            InputValidator::validate_server_name(name)?;
            InputValidator::validate_command(command)?;
            InputValidator::validate_args(args)?;
            
            if let Some(desc) = description {
                InputValidator::validate_description(desc)?;
            }
            
            // Parse and validate environment variables if provided
            let environment = if let Some(env_str) = env {
                Some(InputValidator::validate_environment(env_str)?)
            } else {
                None
            };
            
            // Parse and validate disabled tools if provided
            let disabled_tools_list = if let Some(tools_str) = disabled_tools {
                Some(InputValidator::validate_disabled_tools(tools_str)?)
            } else {
                None
            };
            
            let profile = ServerProfile {
                id: Uuid::new_v4().to_string(),
                name: name.clone(),
                description: description.clone(),
                command: command.clone(),
                args: args.clone(),
                environment,
                timeout: *timeout,
                is_default: *set_default,
                transport: transport.map(|t| t.to_string()),
                disabled_tools: disabled_tools_list,
                created_at: Utc::now(),
                last_used: None,
            };
            
            config_manager.add_server(profile).await?;
            info!("✅ Added server profile: {}", name);
            
            if *set_default {
                info!("✅ Set as default server");
            }
        }
        
        ServerCommands::List => {
            let servers = config_manager.list_servers().await?;
            
            if servers.is_empty() {
                info!("No server profiles configured");
            } else {
                info!("Server profiles:");
                for server in servers {
                    let default_marker = if server.is_default { " (default)" } else { "" };
                    let transport = server.transport.as_deref().unwrap_or("stdio");
                    info!("  {} - {} [{}]{}",
                        server.name,
                        server.command,
                        transport,
                        default_marker
                    );
                    if let Some(desc) = &server.description {
                        info!("    {}", desc);
                    }
                }
            }
        }
        
        ServerCommands::SetDefault { name } => {
            config_manager.set_default_server(name).await?;
            info!("✅ Set '{}' as default server", name);
        }
        
        ServerCommands::Remove { name } => {
            config_manager.remove_server(name).await?;
            info!("✅ Removed server profile: {}", name);
        }
        
        ServerCommands::Export { format } => {
            let servers = config_manager.list_servers().await?;
            match format.as_str() {
                "json" => {
                    info!("{}", serde_json::to_string_pretty(&servers)?);
                }
                _ => {
                    info!("{}", serde_json::to_string_pretty(&servers)?);
                }
            }
        }
        
        ServerCommands::Import { path } => {
            let content = std::fs::read_to_string(path)
                .map_err(|e| ClientError::ConfigError(format!("Failed to read file: {}", e)))?;
            
            let servers: Vec<ServerProfile> = serde_json::from_str(&content)
                .map_err(|e| ClientError::ConfigError(format!("Invalid JSON: {}", e)))?;
            
            for server in servers {
                config_manager.add_server(server).await?;
            }
            
            info!("✅ Imported configuration successfully");
        }
        
        ServerCommands::Get { name } => {
            let server = config_manager.get_server(name).await?
                .ok_or_else(|| ClientError::ConfigError(format!("Server '{}' not found", name)))?;
            
            info!("Server: {}", server.name);
            info!("Command: {}", server.command);
            if !server.args.is_empty() {
                info!("Arguments: {}", server.args.join(" "));
            }
            if let Some(desc) = &server.description {
                info!("Description: {}", desc);
            }
            if let Some(transport) = &server.transport {
                info!("Transport: {}", transport);
            } else {
                info!("Transport: stdio (default)");
            }
            if let Some(timeout) = server.timeout {
                info!("Timeout: {}s", timeout);
            }
            if let Some(env) = &server.environment {
                info!("Environment: {}", serde_json::to_string_pretty(env)?);
            }
            if let Some(tools) = &server.disabled_tools {
                info!("Disabled tools: {}", tools.join(", "));
            }
            info!("Default: {}", if server.is_default { "Yes" } else { "No" });
            info!("Created: {}", server.created_at.format("%Y-%m-%d %H:%M:%S UTC"));
            if let Some(last_used) = server.last_used {
                info!("Last used: {}", last_used.format("%Y-%m-%d %H:%M:%S UTC"));
            }
        }
        
        ServerCommands::AddJson { name, json } => {
            // Validate name
            InputValidator::validate_server_name(name)?;
            
            // Validate JSON structure before parsing
            InputValidator::validate_json_input(json)?;
            
            let mut profile: ServerProfile = serde_json::from_str(json)
                .map_err(|e| ClientError::ConfigError(format!("Invalid JSON: {}", e)))?;
            
            // Validate the parsed profile data
            InputValidator::validate_command(&profile.command)?;
            InputValidator::validate_args(&profile.args)?;
            
            if let Some(desc) = &profile.description {
                InputValidator::validate_description(desc)?;
            }
            
            if let Some(env) = &profile.environment {
                // Validate each environment variable
                for (key, value) in env {
                    InputValidator::validate_identifier(key, "Environment variable name", false)?;
                    InputValidator::check_dangerous_patterns(value)?;
                    InputValidator::check_unicode_attacks(value)?;
                }
            }
            
            if let Some(tools) = &profile.disabled_tools {
                for tool in tools {
                    InputValidator::validate_identifier(tool, "Tool name", true)?;
                }
            }
            
            // Override the name with the provided one
            profile.name = name.clone();
            profile.id = Uuid::new_v4().to_string();
            profile.created_at = Utc::now();
            
            config_manager.add_server(profile).await?;
            info!("✅ Added server profile from JSON: {}", name);
        }
    }
    
    Ok(())
}