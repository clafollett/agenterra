//! Transport abstraction layer for MCP communication in {{ project_name }}
//!
//! {{ description }}
//! Version: {{ version }}
//! Protocol: 2025-06-18

use crate::error::Result;
use async_trait::async_trait;

/// Abstraction over different MCP transport mechanisms for {{ project_name }}
#[async_trait]
pub trait Transport: Send + Sync {
    /// Send a message and receive a response
    async fn send(&mut self, message: serde_json::Value) -> Result<serde_json::Value>;

    /// Close the transport gracefully
    async fn close(&mut self) -> Result<()>;
}

/// Mock transport for testing {{ project_name }}
#[cfg(test)]
pub struct MockTransport {
    responses: Vec<serde_json::Value>,
    call_count: usize,
    max_responses: usize,
}

#[cfg(test)]
impl MockTransport {
    pub fn new(responses: Vec<serde_json::Value>) -> Self {
        let max_responses = responses.len();
        Self {
            responses,
            call_count: 0,
            max_responses,
        }
    }

    /// Create mock transport with configurable limit
    pub fn with_limit(responses: Vec<serde_json::Value>, limit: usize) -> Self {
        Self {
            responses,
            call_count: 0,
            max_responses: limit.min(1000),
        }
    }
}

#[cfg(test)]
#[async_trait]
impl Transport for MockTransport {
    async fn send(&mut self, _message: serde_json::Value) -> Result<serde_json::Value> {
        use crate::error::ClientError;

        // Check if we've exceeded the maximum allowed responses
        if self.call_count >= self.max_responses {
            return Err(ClientError::Transport(
                "Maximum response limit reached".to_string(),
            ));
        }

        if self.call_count >= self.responses.len() {
            return Err(ClientError::Transport("No more mock responses".to_string()));
        }

        let response = self.responses[self.call_count].clone();
        self.call_count += 1;
        Ok(response)
    }

    async fn close(&mut self) -> Result<()> {
        Ok(())
    }
}