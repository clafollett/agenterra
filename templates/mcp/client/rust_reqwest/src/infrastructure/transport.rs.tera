//! Transport abstraction layer for MCP communication in {{ project_name }}
//!
//! {{ description }}
//! Version: {{ version }}
//! Protocol: 2025-06-18

use crate::infrastructure::error::Result;
use async_trait::async_trait;
use clap::ValueEnum;
use serde::{Deserialize, Serialize};

/// Transport protocol selection for MCP connection
#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TransportProtocol {
    /// Standard I/O (process communication)
    #[value(name = "stdio")]
    Stdio,
    
    /// Server-Sent Events (HTTP-based)
    #[value(name = "sse")]
    Sse,
}

impl Default for TransportProtocol {
    fn default() -> Self {
        Self::Stdio
    }
}

impl From<&str> for TransportProtocol {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "sse" => Self::Sse,
            "stdio" | _ => Self::Stdio,
        }
    }
}

impl From<String> for TransportProtocol {
    fn from(s: String) -> Self {
        Self::from(s.as_str())
    }
}

impl From<Option<&str>> for TransportProtocol {
    fn from(s: Option<&str>) -> Self {
        s.map(Self::from).unwrap_or_default()
    }
}

impl From<Option<String>> for TransportProtocol {
    fn from(s: Option<String>) -> Self {
        s.as_deref().into()
    }
}

impl std::fmt::Display for TransportProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Stdio => write!(f, "stdio"),
            Self::Sse => write!(f, "sse"),
        }
    }
}

/// Abstraction over different MCP transport mechanisms for {{ project_name }}
#[async_trait]
pub trait Transport: Send + Sync {
    /// Send a message and receive a response
    async fn send(&mut self, message: serde_json::Value) -> Result<serde_json::Value>;

    /// Close the transport gracefully
    async fn close(&mut self) -> Result<()>;
}

/// Mock transport for testing {{ project_name }}
#[cfg(test)]
pub struct MockTransport {
    responses: Vec<serde_json::Value>,
    call_count: usize,
    max_responses: usize,
}

#[cfg(test)]
impl MockTransport {
    pub fn new(responses: Vec<serde_json::Value>) -> Self {
        let max_responses = responses.len();
        Self {
            responses,
            call_count: 0,
            max_responses,
        }
    }

    /// Create mock transport with configurable limit
    pub fn with_limit(responses: Vec<serde_json::Value>, limit: usize) -> Self {
        Self {
            responses,
            call_count: 0,
            max_responses: limit.min(1000),
        }
    }
}

#[cfg(test)]
#[async_trait]
impl Transport for MockTransport {
    async fn send(&mut self, _message: serde_json::Value) -> Result<serde_json::Value> {
        use crate::infrastructure::error::ClientError;

        // Check if we've exceeded the maximum allowed responses
        if self.call_count >= self.max_responses {
            return Err(ClientError::Transport(
                "Maximum response limit reached".to_string(),
            ));
        }

        if self.call_count >= self.responses.len() {
            return Err(ClientError::Transport("No more mock responses".to_string()));
        }

        let response = self.responses[self.call_count].clone();
        self.call_count += 1;
        Ok(response)
    }

    async fn close(&mut self) -> Result<()> {
        Ok(())
    }
}