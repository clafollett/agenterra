# MCPGen Template System

This document describes the template system used by MCPGen for code generation from OpenAPI specifications.

## Table of Contents
- [Template Structure](#template-structure)
- [Manifest Format](#manifest-format)
- [Available Template Variables](#available-template-variables)
- [Example Templates](#example-templates)
- [Template Context](#template-context)
- [Conditional Logic](#conditional-logic)
- [Including Other Templates](#including-other-templates)
- [Built-in Filters](#built-in-filters)

## Template Structure

A template directory should have the following structure:

```
template_directory/
├── manifest.yaml    # Required: Template manifest
├── templates/       # Directory containing template files
│   ├── *.tera       # Template files with .tera extension
│   └── subdir/      # Subdirectories are supported
└── hooks/           # Optional: Directory for post-generation hooks
    └── post-generate.sh  # Optional: Script to run after generation
```

## Manifest Format

The `manifest.yaml` file defines the template's metadata and configuration:

```yaml
name: my-template        # Required: Template name
version: 1.0.0           # Required: Template version
description: >           # Optional: Template description
  This template generates a Rust API client
  from an OpenAPI specification.

author: Your Name <email@example.com>  # Optional: Author information

# Template options (all optional)
options:
  # Operation filtering
  all_operations: true    # Include all operations (default: true)
  include_operations:     # Include only these operations (if specified, overrides all_operations)
    - getPets
    - createPet
  exclude_operations:     # Exclude these operations
    - deprecatedOperation

  # Server configuration
  server:
    port: 8080            # Default server port
    log_file: app.log     # Default log file path

# Template files configuration
files:
  - source: templates/client.tera
    target: src/client.rs
    context:              # Optional: Additional context for this file
      custom_var: value
    
  - source: templates/models.tera
    target: src/models/
    template_per_operation: true  # Generate one file per operation
    context:
      is_model: true

# Hooks (optional)
hooks:
  post_generate: hooks/post-generate.sh  # Script to run after generation
```

## Available Template Variables

### Global Variables

| Variable           | Type     | Description                                      |
|--------------------|----------|--------------------------------------------------|
| `project_name`    | String   | Name of the generated project                    |
| `api_version`     | String   | API version from OpenAPI spec                    |
| `spec`            | Object   | The complete OpenAPI specification object        |
| `endpoints`       | Array    | List of endpoint contexts (see below)            |
| `current_time`    | DateTime | Current date and time                            |
| `template_opts`   | Object   | Template options from manifest                   |

### Endpoint Context

Each endpoint in the `endpoints` array has the following structure:

```rust
{
  endpoint: String,           // e.g., "get_pets"
  endpoint_cap: String,       // e.g., "GET_PETS"
  fn_name: String,           // e.g., "get_pets"
  parameters_type: String,   // e.g., "GetPetsParams"
  properties_type: String,   // e.g., "PetProperties"
  response_type: String,     // e.g., "PetResponse"
  envelope_properties: Value, // JSON schema of response properties
  properties: Vec<PropertyInfo>,
  properties_for_handler: Vec<String>,
  parameters: Vec<ParameterInfo>,
  summary: String,
  description: String,
  tags: Vec<String>,
  properties_schema: Map<String, Value>,
  response_schema: Value,
  spec_file_name: Option<String>,
  valid_fields: Vec<String>
}
```

### PropertyInfo

```rust
struct PropertyInfo {
    name: String,
    rust_type: String,
    title: Option<String>,
    description: Option<String>,
    example: Option<Value>
}
```

### ParameterInfo

```rust
struct ParameterInfo {
    name: String,
    rust_type: String,
    description: Option<String>,
    example: Option<Value>
}
```

## Example Templates

### Basic Template Example (`client.tera`)

```rust
// Generated by MCPGen - {{ current_time }}
// API Version: {{ api_version }}


use serde::{{Serialize, Deserialize}};

{% for endpoint in endpoints %}
/// {{ endpoint.summary }}
/// 
/// {{ endpoint.description }}
pub async fn {{ endpoint.fn_name }}(
    client: &Client,
    params: {{ endpoint.parameters_type }}
) -> Result<{{ endpoint.response_type }}, Error> {
    let url = format!("{}/api/{}", client.base_url, "{{ endpoint.endpoint }}");
    let response = client.get(&url).query(¶ms).send().await?;
    response.json().await
}

{% endfor %}
```

### Model Template Example (`models.tera`)

```rust
// Generated by MCPGen - {{ current_time }}

use serde::{{Serialize, Deserialize}};

{% for endpoint in endpoints %}
#[derive(Debug, Serialize, Deserialize)]
pub struct {{ endpoint.response_type }} {
    {% for prop in endpoint.properties %}
    /// {{ prop.description | default(value="") }}
    #[serde(rename = "{{ prop.name }}")]
    pub {{ prop.name | snake_case }}: {{ prop.rust_type }}{% if prop.example %} // Example: {{ prop.example | json_encode | safe }}{% endif %},
    {% endfor %}
}

{% endfor %}
```

## Template Context

Templates have access to a rich context that includes:

1. **Global Context**: Available in all templates
   - `project_name`: Name of the generated project
   - `api_version`: Version from the OpenAPI spec
   - `current_time`: Timestamp of generation
   - `template_opts`: Options from the manifest

2. **Endpoint-Specific Context**: When using `template_per_operation`, each template gets:
   - `endpoint`: The current endpoint context
   - All global context variables

## Conditional Logic

You can use Tera's control structures for conditional generation:

```jinja
{% if endpoint.tags contains "admin" %}
// This is an admin-only endpoint
#[requires_role("admin")]
{% endif %}
```

## Including Other Templates

Use Tera's `include` to reuse template fragments:

```jinja
{% include "common/header.tera" %}

// Your template content here

{% include "common/footer.tera" %}
```

## Built-in Filters

MCPGen includes several useful Tera filters:

- `camel_case`: Convert string to camelCase
- `pascal_case`: Convert string to PascalCase
- `snake_case`: Convert string to snake_case
- `kebab_case`: Convert string to kebab-case
- `json_encode`: Convert value to JSON string
- `type_rs`: Convert OpenAPI type to Rust type

Example:
```jinja
{{ "user_name" | snake_case }}  // user_name
{{ "user_name" | camel_case }}  // userName
{{ "user_name" | pascal_case }} // UserName
{{ "user_name" | kebab_case }}  // user-name
{{ endpoint.parameters | json_encode | safe }}
{{ "string" | type_rs }}  // String
```

## Best Practices

1. **Keep templates simple**: Focus on structure, not complex logic
2. **Use includes**: Break down large templates into smaller, reusable components
3. **Document templates**: Add comments explaining non-obvious parts
4. **Test thoroughly**: Generate code with various OpenAPI specs to ensure robustness
5. **Handle optional fields**: Always check if fields exist before accessing them

## Troubleshooting

- **Missing variables**: Ensure all required variables are passed in the template context
- **Template errors**: Check Tera's error messages for syntax issues
- **Incorrect output**: Verify your OpenAPI spec and template logic
- **Performance issues**: For large specs, consider splitting templates or using `template_per_ocation`
